import { extractStyles } from '../styleExtractor';
import { stylesToTailwind } from '../../transformers/stylesToTailwind';
import { DesignTokens } from '../../types/designTokenTypes';
import { cleanupTailwindClasses } from '../utils/styleUtils';
import { isImageNode, generateImageComponent } from './imageComponent';
import { generateSvgComponent } from './svgComponent';
import { generateComponentName } from '../../utils/nameUtils';
import { getComponentProps } from '../utils/nodeUtils';

/**
 * Generates the body content for a component based on its node type
 */
export async function generateComponentBody(
  node: SceneNode,
  tokens: DesignTokens
): Promise<string> {
  const styles = await extractStyles(node);
  const tailwindClasses = cleanupTailwindClasses(stylesToTailwind(styles, tokens));
  
  // Remove any unwanted auto-generated background colors
  const cleanedClasses = removeAutoGeneratedBackgrounds(tailwindClasses);
  
  let childContent = '';

  // Check if this node has meaningful styles that require a container
  const hasSignificantStyles = isNodeStyleSignificant(cleanedClasses);

  if ('children' in node && node.children && node.children.length > 0) {

    // If there's only one child and current node doesn't have significant styles,
    // we can potentially pass the styles to the child instead of creating a wrapper
    if (node.children.length === 1 && !hasSignificantStyles && 
        !['INSTANCE', 'COMPONENT', 'COMPONENT_SET'].includes(node.children[0].type)) {
      // Pass the parent's styles to the only child
      return await generateComponentBodyWithParentStyles(node.children[0], tokens, cleanedClasses);
    }
    
    // Process multiple children
    for (const child of node.children) {
      if (child.type === 'INSTANCE') {
        const mainComponent = await child.getMainComponentAsync();
        if (mainComponent) {
          // Extract the base component name - take the part before any comma
          // which usually separates the component name from its variants
          const baseComponentName = child.name.split(',')[0].trim();
          const instanceComponentName = generateComponentName(baseComponentName);
          
          // Extract variant properties from the instance
          const props = getComponentProps(child);
          const propsString = props.length > 0 ? ` ${props.join(' ')}` : '';
          
          childContent += `      <${instanceComponentName}${propsString} id="${child.name}" />`;
        } else {
          const generatedContent = await generateComponentBody(child, tokens);
          // Preserve formatting for multiline content
          childContent += generatedContent;
        }
      } else {
        if (childContent && !childContent.endsWith('\n')) {
          childContent += '\n';
        }
        childContent += await generateComponentBody(child, tokens);
      }
      // Add proper spacing between elements
      
    }
  }

  // If node has no children and no significant styles, and it's not a container node type,
  // we can skip generating a div altogether
  if (!childContent && !hasSignificantStyles && 
      !['FRAME', 'GROUP', 'INSTANCE', 'COMPONENT'].includes(node.type)) {
    return '';
  }

  const wrapWithElement = (element: string, content: string = '') => {
    const classes = cleanedClasses.trim();
    
    // For elements with no classes
    if (!classes) {
      // Empty elements with no content or classes
      if (!content) {
        return `<${element} id="${node.name}" />`;
      }
      // Format children properly
      if (content.includes('\n')) {
        return `<${element} id="${node.name}">\n  ${content.trim()}\n</${element}>`;
      }
      return `<${element} id="${node.name}">${content.trim()}</${element}>`;
    }
    
    // For empty elements with only classes (self-closing)
    if (!content) {
      return `<${element} id="${node.name}" className="${classes}" />`;
    }
    
    // For elements with content, handle formatting based on content complexity
    if (content.includes('\n')) {
      return `<${element} id="${node.name}" className="${classes}">\n  ${content.trim()}\n</${element}>`;
    }
    
    // Simple content on a single line
    return `<${element} id="${node.name}" className="${classes}">${content.trim()}</${element}>`;
  };

  // Handle image nodes
  if (isImageNode(node)) {
    return generateImageComponent(node, cleanedClasses);
  }

  switch (node.type) {
    case 'TEXT': {
      // Determine the appropriate text element based on context and styles
      let element = 'span';
      const isHeading = node.name.toLowerCase().includes('heading') || 
                       node.name.toLowerCase().includes('title') ||
                       cleanedClasses.includes('text-2xl') ||
                       cleanedClasses.includes('text-3xl') ||
                       cleanedClasses.includes('text-4xl');
      
      const isParagraph = node.characters.length > 100 || 
                         node.characters.includes('\n') ||
                         node.name.toLowerCase().includes('paragraph') ||
                         node.name.toLowerCase().includes('body');
      
      if (isHeading) {
        // Determine heading level based on text size or name
        if (cleanedClasses.includes('text-4xl')) element = 'h1';
        else if (cleanedClasses.includes('text-3xl')) element = 'h2';
        else if (cleanedClasses.includes('text-2xl')) element = 'h3';
        else element = 'h4';
      } else if (isParagraph) {
        element = 'p';
      }
      
      // For short text elements, use a simpler single-line format
      if (node.characters.length < 50 && !node.characters.includes('\n')) {
        const classes = cleanedClasses.trim();
        if (!classes) {
          return `<${element}>${node.characters}</${element}>\n`;
        }
        return `<${element} className="${classes}">${node.characters}</${element}>\n`;
      }
      
      return wrapWithElement(element, node.characters);
    }
    case 'RECTANGLE':
    case 'ELLIPSE':
      return hasSignificantStyles ? wrapWithElement('div') : '';
    case 'FRAME':
    case 'GROUP':
      // Only create a div if there are significant styles or multiple children
      return hasSignificantStyles || childContent ? wrapWithElement('div', childContent) : childContent;
    case 'VECTOR':
    case 'LINE':
      // Use SVG component for vectors
      return await generateSvgComponent(node, cleanedClasses);
    case 'POLYGON':
    case 'STAR':
      // Use SVG component for polygons and stars
      return await generateSvgComponent(node, cleanedClasses);
    default:
      return childContent || (hasSignificantStyles ? wrapWithElement('div', cleanedClasses) : '');
  }
}

/**
 * Process a node with styles inherited from parent
 */
async function generateComponentBodyWithParentStyles(
  node: SceneNode,
  tokens: DesignTokens,
  parentClasses: string
): Promise<string> {
  const styles = await extractStyles(node);
  let tailwindClasses = cleanupTailwindClasses(stylesToTailwind(styles, tokens));
  
  // Combine parent classes with child classes, removing duplicates
  tailwindClasses = mergeClasses(parentClasses, tailwindClasses);
  
  // Check if this node has meaningful styles that require a container
  const hasSignificantStyles = isNodeStyleSignificant(tailwindClasses);
  
  let childContent = '';
  if ('children' in node && node.children && node.children.length > 0) {
    for (const child of node.children) {
      // Add proper spacing between elements
      if (childContent && !childContent.endsWith('\n')) {
        childContent += '\n';
      }
      childContent += await generateComponentBody(child, tokens);
    }
  }
  
  const wrapWithElement = (element: string, content: string = '') => {
    const classes = tailwindClasses.trim();
    
    // For elements with no classes
    if (!classes) {
      // Empty elements with no content or classes
      if (!content) {
        return `<${element} />`;
      }
      // Format children properly
      if (content.includes('\n')) {
        return `<${element} id="${node.name}-wrapper">\n  ${content.trim()}\n</${element}>`;
      }
      return `<${element} id="${node.name}-wrapper">${content.trim()}</${element}>`;
    }
    
    // For empty elements with only classes (self-closing)
    if (!content) {
      return `<${element} className="${classes}" />`;
    }
    
    // For elements with content, handle formatting based on content complexity
    if (content.includes('\n')) {
      return `<${element} className="${classes}">\n  ${content.trim()}\n</${element}>`;
    }
    
    // Simple content on a single line
    return `<${element} className="${classes}">${content.trim()}</${element}>`;
  };

  // Handle node types similarly to generateComponentBody
  if (isImageNode(node)) {
    return generateImageComponent(node, tailwindClasses);
  }

  switch (node.type) {
    case 'TEXT': {
      // Determine the appropriate text element based on context and styles
      let element = 'span';
      const isHeading = node.name.toLowerCase().includes('heading') || 
                       node.name.toLowerCase().includes('title') ||
                       tailwindClasses.includes('text-2xl') ||
                       tailwindClasses.includes('text-3xl') ||
                       tailwindClasses.includes('text-4xl');
      
      const isParagraph = node.characters.length > 100 || 
                         node.characters.includes('\n') ||
                         node.name.toLowerCase().includes('paragraph') ||
                         node.name.toLowerCase().includes('body');
      
      if (isHeading) {
        // Determine heading level based on text size or name
        if (tailwindClasses.includes('text-4xl')) element = 'h1';
        else if (tailwindClasses.includes('text-3xl')) element = 'h2';
        else if (tailwindClasses.includes('text-2xl')) element = 'h3';
        else element = 'h4';
      } else if (isParagraph) {
        element = 'p';
      }
      
      // For short text elements, use a simpler single-line format
      if (node.characters.length < 50 && !node.characters.includes('\n')) {
        const classes = tailwindClasses.trim();
        if (!classes) {
          return `<${element}>${node.characters}</${element}>\n`;
        }
        return `<${element} className="${classes}">${node.characters}</${element}>\n`;
      }
      
      return wrapWithElement(element, node.characters);
    }
    case 'RECTANGLE':
    case 'ELLIPSE':
      return hasSignificantStyles ? wrapWithElement('div') : '';
    case 'FRAME':
    case 'GROUP':
      return hasSignificantStyles || childContent ? wrapWithElement('div', childContent) : childContent;
    case 'VECTOR':
    case 'LINE':
      return await generateSvgComponent(node, tailwindClasses);
    case 'POLYGON':
    case 'STAR':
      return await generateSvgComponent(node, tailwindClasses);
    default:
      return childContent || (hasSignificantStyles ? wrapWithElement('div') : '');
  }
}

/**
 * Check if a node has styles that are significant enough to warrant a container
 */
function isNodeStyleSignificant(classes: string): boolean {
  // If no classes, no need for a container
  if (!classes || classes.trim() === '') {
    return false;
  }
  
  // Patterns that indicate significant styling that needs its own element
  const significantPatterns = [
    /bg-/, // Background
    /border/, // Border
    /shadow/, // Shadow
    /flex-/, // Flex container properties
    /grid-/, // Grid properties
    /absolute/, /relative/, /fixed/, // Positioning
    /z-/, // Z-index
    /overflow-/, // Overflow
    /opacity-/, // Opacity
    /rounded/, // Border radius
    /m[trblxy]?-/, /p[trblxy]?-/, // Margin and padding
    /h-/, /w-/, /min-h-/, /min-w-/, /max-h-/, /max-w-/ // Size constraints
  ];
  
  // If any significant pattern is found, we need a container
  return significantPatterns.some(pattern => pattern.test(classes));
}

/**
 * Merge two class strings, removing duplicates
 */
function mergeClasses(parentClasses: string, childClasses: string): string {
  const parentClassArray = parentClasses.split(' ').filter(Boolean);
  const childClassArray = childClasses.split(' ').filter(Boolean);
  
  // Combine classes, giving precedence to child classes for conflicts
  const combinedClasses = [...parentClassArray];
  
  childClassArray.forEach(childClass => {
    // Extract the base property (like 'w-', 'h-', 'bg-', etc.)
    const childBaseProp = childClass.match(/^([a-z-]+(?=-|$))/);
    
    if (childBaseProp) {
      // Remove any parent class that sets the same property
      const baseToRemove = childBaseProp[1];
      const indexToRemove = combinedClasses.findIndex(
        pc => pc.startsWith(baseToRemove + '-') || pc === baseToRemove
      );
      
      if (indexToRemove >= 0) {
        combinedClasses.splice(indexToRemove, 1);
      }
    }
    
    // Add the child class
    combinedClasses.push(childClass);
  });
  
  return combinedClasses.join(' ');
}

/**
 * Remove any background classes that might have been auto-generated
 */
function removeAutoGeneratedBackgrounds(classes: string): string {
  // Split the classes
  const classArray = classes.split(' ').filter(Boolean);
  
  // Check if element has specific, intentional background styles
  const hasExplicitBackground = classArray.some(cls => 
    cls.startsWith('bg-[') || // Custom backgrounds like bg-[#fff]
    cls === 'bg-transparent' || 
    cls === 'bg-inherit'
  );
  
  // If it has explicit backgrounds, keep them
  if (hasExplicitBackground) {
    return classes;
  }
  
  // Otherwise, filter out any default background colors
  const filteredClasses = classArray.filter(cls => 
    !cls.startsWith('bg-white') && 
    !cls.startsWith('bg-gray-') && 
    !cls.startsWith('bg-primary-') && 
    !cls.startsWith('bg-secondary-') &&
    !cls.startsWith('bg-red-') && 
    !cls.startsWith('bg-green-')
  );
  
  return filteredClasses.join(' ');
} 